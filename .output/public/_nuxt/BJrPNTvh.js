import{e as N,i as H,j as O,k as g,l as q,m as I,p as U,q as W,s as z,x as V,y as L,z as G,r as J,A as w,B as R,C as Q,D as X,E as S,F as Y,G as Z,H as x,I as K,J as k,K as A,L as ee,M as ae,f as te,N as se,o as ne}from"#entry";const re={trailing:!0};function ie(e,a=25,i={}){if(i={...re,...i},!Number.isFinite(a))throw new TypeError("Expected `wait` to be a finite number");let r,s,o=[],n,t;const h=(u,y)=>(n=ce(e,u,y),n.finally(()=>{if(n=null,i.trailing&&t&&!s){const b=h(u,t);return t=null,b}}),n),D=function(...u){return i.trailing&&(t=u),n||new Promise(y=>{const b=!s&&i.leading;clearTimeout(s),s=setTimeout(()=>{s=null;const f=i.leading?r:h(this,u);t=null;for(const l of o)l(f);o=[]},a),b?(r=h(this,u),y(r)):o.push(y)})},c=u=>{u&&(clearTimeout(u),s=null)};return D.isPending=()=>!!s,D.cancel=()=>{c(s),o=[],t=null},D.flush=()=>{if(c(s),!t||n)return;const u=t;return t=null,h(this,u)},D}async function ce(e,a,i){return await e.apply(a,i)}const oe=e=>e==="defer"||e===!1;function ue(...e){const a=typeof e[e.length-1]=="string"?e.pop():void 0;le(e[0],e[1])&&e.unshift(a);let[i,r,s={}]=e,o=!1;const n=N(()=>H(i));if(typeof n.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof r!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const t=O();s.server??=!0,s.default??=de,s.getCachedData??=j,s.lazy??=!1,s.immediate??=!0,s.deep??=g.deep,s.dedupe??="cancel",s._functionName,t._asyncData[n.value];function h(){const f={cause:"initial",dedupe:s.dedupe};return t._asyncData[n.value]?._init||(f.cachedData=s.getCachedData(n.value,t,{cause:"initial"}),t._asyncData[n.value]=B(t,n.value,r,s,f.cachedData)),()=>t._asyncData[n.value].execute(f)}const D=h(),c=t._asyncData[n.value];c._deps++;const u=s.server!==!1&&t.payload.serverRendered;{let f=function(d){const _=t._asyncData[d];_?._deps&&(_._deps--,_._deps===0&&_?._off())};const l=q();if(l&&u&&s.immediate&&!l.sp&&(l.sp=[]),l&&!l._nuxtOnBeforeMountCbs){l._nuxtOnBeforeMountCbs=[];const d=l._nuxtOnBeforeMountCbs;I(()=>{d.forEach(_=>{_()}),d.splice(0,d.length)}),U(()=>d.splice(0,d.length))}const v=l&&(l._nuxtClientOnly||W(z,!1));u&&t.isHydrating&&(c.error.value||c.data.value!=null)?(c.pending.value=!1,c.status.value=c.error.value?"error":"success"):l&&(!v&&t.payload.serverRendered&&t.isHydrating||s.lazy)&&s.immediate?l._nuxtOnBeforeMountCbs.push(D):s.immediate&&D();const m=G(),P=V(n,(d,_)=>{if((d||_)&&d!==_){o=!0;const E=t._asyncData[_]?.data.value!==g.value,$=t._asyncDataPromises[_]!==void 0,T={cause:"initial",dedupe:s.dedupe};if(!t._asyncData[d]?._init){let p;_&&E?p=t._asyncData[_].data.value:(p=s.getCachedData(d,t,{cause:"initial"}),T.cachedData=p),t._asyncData[d]=B(t,d,r,s,p)}t._asyncData[d]._deps++,_&&f(_),(s.immediate||E||$)&&t._asyncData[d].execute(T),Y(()=>{o=!1})}},{flush:"sync"}),M=s.watch?V(s.watch,()=>{o||c._execute({cause:"watch",dedupe:s.dedupe})}):()=>{};m&&L(()=>{P(),M(),f(n.value)})}const y={data:C(()=>t._asyncData[n.value]?.data),pending:C(()=>t._asyncData[n.value]?.pending),status:C(()=>t._asyncData[n.value]?.status),error:C(()=>t._asyncData[n.value]?.error),refresh:(...f)=>t._asyncData[n.value]?._init?t._asyncData[n.value].execute(...f):h()(),execute:(...f)=>y.refresh(...f),clear:()=>F(t,n.value)},b=Promise.resolve(t._asyncDataPromises[n.value]).then(()=>y);return Object.assign(b,y),b}function C(e){return N({get(){return e()?.value},set(a){const i=e();i&&(i.value=a)}})}function le(e,a){return!(typeof e=="string"||typeof e=="object"&&e!==null||typeof e=="function"&&typeof a=="function")}function F(e,a){a in e.payload.data&&(e.payload.data[a]=void 0),a in e.payload._errors&&(e.payload._errors[a]=g.errorValue),e._asyncData[a]&&(e._asyncData[a].data.value=void 0,e._asyncData[a].error.value=g.errorValue,e._asyncData[a].pending.value=!1,e._asyncData[a].status.value="idle"),a in e._asyncDataPromises&&(e._asyncDataPromises[a]&&(e._asyncDataPromises[a].cancelled=!0),e._asyncDataPromises[a]=void 0)}function fe(e,a){const i={};for(const r of a)i[r]=e[r];return i}function B(e,a,i,r,s){e.payload._errors[a]??=g.errorValue;const o=r.getCachedData!==j,n=i,t=r.deep?J:w,h=s!=null,D=e.hook("app:data:refresh",async u=>{(!u||u.includes(a))&&await c.execute({cause:"refresh:hook"})}),c={data:t(h?s:r.default()),pending:w(!h),error:R(e.payload._errors,a),status:w("idle"),execute:(...u)=>{const[y,b=void 0]=u,f=y&&b===void 0&&typeof y=="object"?y:{};if(e._asyncDataPromises[a]){if(oe(f.dedupe??r.dedupe))return e._asyncDataPromises[a];e._asyncDataPromises[a].cancelled=!0}if(f.cause==="initial"||e.isHydrating){const v="cachedData"in f?f.cachedData:r.getCachedData(a,e,{cause:f.cause??"refresh:manual"});if(v!=null)return e.payload.data[a]=c.data.value=v,c.error.value=g.errorValue,c.status.value="success",Promise.resolve(v)}c.pending.value=!0,c.status.value="pending";const l=new Promise((v,m)=>{try{v(n(e))}catch(P){m(P)}}).then(async v=>{if(l.cancelled)return e._asyncDataPromises[a];let m=v;r.transform&&(m=await r.transform(v)),r.pick&&(m=fe(m,r.pick)),e.payload.data[a]=m,c.data.value=m,c.error.value=g.errorValue,c.status.value="success"}).catch(v=>{if(l.cancelled)return e._asyncDataPromises[a];c.error.value=X(v),c.data.value=S(r.default()),c.status.value="error"}).finally(()=>{l.cancelled||(c.pending.value=!1,delete e._asyncDataPromises[a])});return e._asyncDataPromises[a]=l,e._asyncDataPromises[a]},_execute:ie((...u)=>c.execute(...u),0,{leading:!0}),_default:r.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{D(),e._asyncData[a]?._init&&(e._asyncData[a]._init=!1),o||Q(()=>{e._asyncData[a]?._init||(F(e,a),c.execute=()=>Promise.resolve(),c.data.value=g.value)})}};return c}const de=()=>g.value,j=(e,a,i)=>{if(a.isHydrating)return a.payload.data[e];if(i.cause!=="refresh:manual"&&i.cause!=="refresh:hook")return a.static.data[e]},_e="$s";function ye(...e){const a=typeof e[e.length-1]=="string"?e.pop():void 0;typeof e[0]!="string"&&e.unshift(a);const[i,r]=e;if(!i||typeof i!="string")throw new TypeError("[nuxt] [useState] key must be a string: "+i);if(r!==void 0&&typeof r!="function")throw new Error("[nuxt] [useState] init must be a function: "+r);const s=_e+i,o=O(),n=R(o.payload.state,s);if(n.value===void 0&&r){const t=r();if(Z(t))return o.payload.state[s]=t,t;n.value=t}return n}const ve=async(e,a={},i={})=>{const r=x(),s=`${JSON.stringify(a)}${e}`,o=ye(`${s}-state`);if(K(()=>{o.value&&o.value.id&&k(o.value.id,n=>o.value=n,i)}),!o.value){const{data:n}=await ue(s,()=>r.get(`cdn/stories/${e}`,a),"$UWpoAmqTPy");n&&(o.value=n.value?.data.story)}return o},De={__name:"[...slug]",async setup(e){let a,i;const{slug:r}=A().params,s=([a,i]=ee(()=>ve(r&&r.length>0?r.join("/"):"home",{version:"draft"})),a=await a,i(),a);return(o,n)=>{const t=se("StoryblokComponent");return S(s)?(ne(),ae(t,{key:0,blok:S(s).content},null,8,["blok"])):te("",!0)}}};export{De as default};
